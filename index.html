<!DOCTYPE html>
<html lang="ar">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
  <title>ğŸ Ù„Ø¹Ø¨Ø© Ø§Ù„Ø«Ø¹Ø¨Ø§Ù† Ø¨Ø§Ù„ÙŠØ¯ ğŸ</title>
  <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs"></script>
  <script src="https://cdn.jsdelivr.net/npm/@tensorflow-models/handpose"></script>
  <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs-backend-webgl"></script>
  <style>
    :root {
      --primary-color: #00ff00;
      --secondary-color: #ff0000;
      --background-color: #101010;
      --text-color: #ffffff;
      --accent-color: #ffcc00;
    }
    
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }
    
    body {
      margin: 0;
      overflow: hidden;
      background: radial-gradient(circle, var(--background-color), #000);
      color: var(--text-color);
      font-family: "Cairo", Arial, sans-serif;
      text-align: center;
      height: 100vh;
      touch-action: none;
    }
    
    #game-container {
      position: relative;
      width: 100vw;
      height: 100vh;
      overflow: hidden;
      display: flex;
    }
    
    #camera-section {
      width: 50%;
      height: 100%;
      position: relative;
      overflow: hidden;
    }
    
    #game-section {
      width: 50%;
      height: 100%;
      position: relative;
      overflow: hidden;
    }
    
    #start-screen, #game-over-screen {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      background: rgba(0, 0, 0, 0.85);
      z-index: 10;
      padding: 20px;
    }
    
    #game-over-screen {
      display: none;
    }
    
    h1 {
      font-size: 2.5rem;
      margin-bottom: 20px;
      color: var(--primary-color);
      text-shadow: 0 0 10px var(--primary-color);
    }
    
    h2 {
      font-size: 2rem;
      margin-bottom: 20px;
      color: var(--accent-color);
    }
    
    p {
      font-size: 1.2rem;
      margin-bottom: 15px;
      max-width: 90%;
      line-height: 1.5;
    }
    
    .btn {
      background: var(--primary-color);
      color: #000;
      border: none;
      padding: 12px 30px;
      font-size: 1.2rem;
      border-radius: 50px;
      cursor: pointer;
      margin-top: 20px;
      font-weight: bold;
      transition: all 0.3s;
      box-shadow: 0 0 15px var(--primary-color);
    }
    
    .btn:hover {
      background: var(--accent-color);
      transform: scale(1.05);
    }
    
    #canvas {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      z-index: 2;
    }
    
    #video {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      object-fit: cover;
      z-index: 1;
      transform: scaleX(-1); /* Ù…Ø±Ø¢Ø© Ù„Ù„ÙƒØ§Ù…ÙŠØ±Ø§ */
    }
    
    #hand-canvas {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      z-index: 3;
    }
    
    #score-display {
      position: absolute;
      top: 20px;
      left: 20px;
      font-size: 1.5rem;
      z-index: 5;
      background: rgba(0, 0, 0, 0.7);
      padding: 10px 15px;
      border-radius: 10px;
      border: 2px solid var(--primary-color);
    }
    
    #instructions {
      position: absolute;
      bottom: 20px;
      left: 50%;
      transform: translateX(-50%);
      font-size: 1rem;
      z-index: 5;
      background: rgba(0, 0, 0, 0.7);
      padding: 10px 15px;
      border-radius: 10px;
      max-width: 90%;
      border: 2px solid var(--accent-color);
    }
    
    #loading {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      font-size: 1.5rem;
      z-index: 15;
      background: rgba(0, 0, 0, 0.8);
      padding: 20px;
      border-radius: 10px;
    }
    
    .particle {
      position: absolute;
      border-radius: 50%;
      pointer-events: none;
      z-index: 3;
    }
    
    .hand-indicator {
      position: absolute;
      width: 30px;
      height: 30px;
      background: rgba(255, 255, 255, 0.8);
      border-radius: 50%;
      z-index: 4;
      pointer-events: none;
      display: none;
      box-shadow: 0 0 10px var(--primary-color);
    }
    
    #ai-assist {
      position: absolute;
      top: 80px;
      left: 20px;
      font-size: 1rem;
      z-index: 5;
      background: rgba(0, 0, 0, 0.7);
      padding: 10px 15px;
      border-radius: 10px;
      border: 2px solid var(--accent-color);
      max-width: 250px;
    }
    
    #camera-label {
      position: absolute;
      top: 20px;
      left: 50%;
      transform: translateX(-50%);
      font-size: 1.2rem;
      z-index: 5;
      background: rgba(0, 0, 0, 0.7);
      padding: 10px 15px;
      border-radius: 10px;
      border: 2px solid var(--primary-color);
    }
    
    #game-label {
      position: absolute;
      top: 20px;
      left: 50%;
      transform: translateX(-50%);
      font-size: 1.2rem;
      z-index: 5;
      background: rgba(0, 0, 0, 0.7);
      padding: 10px 15px;
      border-radius: 10px;
      border: 2px solid var(--primary-color);
    }
  </style>
</head>
<body>
  <div id="game-container">
    <div id="loading">Ø¬Ø§Ø±ÙŠ ØªØ­Ù…ÙŠÙ„ Ø§Ù„Ù†Ù…ÙˆØ°Ø¬...</div>
    
    <div id="start-screen">
      <h1>ğŸ Ù„Ø¹Ø¨Ø© Ø§Ù„Ø«Ø¹Ø¨Ø§Ù† Ø¨Ø§Ù„ÙŠØ¯ ğŸ</h1>
      <p>Ø§Ø³ØªØ®Ø¯Ù… Ø¥ØµØ¨Ø¹ Ø§Ù„Ø³Ø¨Ø§Ø¨Ø© Ù„Ù„ØªØ­ÙƒÙ… ÙÙŠ Ø§Ù„Ø«Ø¹Ø¨Ø§Ù† ÙˆØªÙ†Ø§ÙˆÙ„ Ø§Ù„ØªÙØ§Ø­!</p>
      <p>Ø§Ù„Ù„Ø¹Ø¨Ø© ØªØ³ØªØ®Ø¯Ù… Ø§Ù„Ø°ÙƒØ§Ø¡ Ø§Ù„Ø§ØµØ·Ù†Ø§Ø¹ÙŠ Ù„ØªØ³Ù‡ÙŠÙ„ Ø§Ù„ØªØ­ÙƒÙ…</p>
      <p>Ø­Ø§ÙˆÙ„ ØªØ¬Ù†Ø¨ Ø§Ù„Ø§ØµØ·Ø¯Ø§Ù… Ø¨Ù†ÙØ³Ùƒ!</p>
      <button id="start-btn" class="btn">Ø§Ø¨Ø¯Ø£ Ø§Ù„Ù„Ø¹Ø¨</button>
    </div>
    
    <div id="game-over-screen">
      <h2>Ø§Ù†ØªÙ‡Øª Ø§Ù„Ù„Ø¹Ø¨Ø©!</h2>
      <p id="final-score">Ø§Ù„Ù†Ù‚Ø§Ø·: 0</p>
      <button id="restart-btn" class="btn">Ø§Ù„Ø¹Ø¨ Ù…Ø±Ø© Ø£Ø®Ø±Ù‰</button>
    </div>
    
    <!-- Ù‚Ø³Ù… Ø§Ù„ÙƒØ§Ù…ÙŠØ±Ø§ -->
    <div id="camera-section">
      <div id="camera-label">ÙƒØ§Ù…ÙŠØ±Ø§ Ø§Ù„ØªØ­ÙƒÙ…</div>
      <video id="video" autoplay playsinline></video>
      <canvas id="hand-canvas"></canvas>
      <div class="hand-indicator" id="hand-indicator"></div>
    </div>
    
    <!-- Ù‚Ø³Ù… Ø§Ù„Ù„Ø¹Ø¨Ø© -->
    <div id="game-section">
      <div id="game-label">Ù„Ø¹Ø¨Ø© Ø§Ù„Ø«Ø¹Ø¨Ø§Ù†</div>
      <canvas id="canvas"></canvas>
      <div id="score-display">Ø§Ù„Ù†Ù‚Ø§Ø·: 0</div>
      <div id="ai-assist">Ø§Ù„Ù…Ø³Ø§Ø¹Ø¯Ø© Ø§Ù„Ø°ÙƒÙŠØ©: Ù†Ø´Ø·Ø©</div>
      <div id="instructions">Ø­Ø±Ùƒ Ø¥ØµØ¨Ø¹Ùƒ Ù„Ù„ØªØ­ÙƒÙ… ÙÙŠ Ø§Ù„Ø«Ø¹Ø¨Ø§Ù†</div>
    </div>
  </div>

  <script>
    // Ø¹Ù†Ø§ØµØ± DOM
    const video = document.getElementById("video");
    const canvas = document.getElementById("canvas");
    const handCanvas = document.getElementById("hand-canvas");
    const ctx = canvas.getContext("2d");
    const handCtx = handCanvas.getContext("2d");
    const startScreen = document.getElementById("start-screen");
    const gameOverScreen = document.getElementById("game-over-screen");
    const startBtn = document.getElementById("start-btn");
    const restartBtn = document.getElementById("restart-btn");
    const scoreDisplay = document.getElementById("score-display");
    const finalScore = document.getElementById("final-score");
    const loading = document.getElementById("loading");
    const instructions = document.getElementById("instructions");
    const handIndicator = document.getElementById("hand-indicator");
    const aiAssistDisplay = document.getElementById("ai-assist");

    // Ù…ØªØºÙŠØ±Ø§Øª Ø§Ù„Ù„Ø¹Ø¨Ø©
    let model;
    let snake = [];
    let food = {};
    let maxLength = 50;
    let score = 0;
    let gameActive = false;
    let lastPredictionTime = 0;
    let predictionInterval = 80; // ØªØ­Ø¯ÙŠØ« Ø£Ø³Ø±Ø¹ Ù„ØªØ¬Ø±Ø¨Ø© Ø£ÙØ¶Ù„
    let particles = [];
    let lastHandPosition = { x: 0, y: 0 };
    let handDetected = false;
    let aiAssistActive = true;
    let assistLevel = 0.7; // Ù…Ø³ØªÙˆÙ‰ Ø§Ù„Ù…Ø³Ø§Ø¹Ø¯Ø© (0-1)

    // ØªÙ‡ÙŠØ¦Ø© Ø§Ù„Ù„Ø¹Ø¨Ø©
    function initGame() {
      snake = [{x: canvas.width/2, y: canvas.height/2}];
      randomFood();
      maxLength = 50;
      score = 0;
      updateScore();
      gameActive = true;
      handDetected = false;
      aiAssistActive = true;
      assistLevel = 0.7;
      updateAIAssistDisplay();
    }

    // Ø¶Ø¨Ø· Ø­Ø¬Ù… canvas
    function resizeCanvas() {
      const gameSection = document.getElementById('game-section');
      const cameraSection = document.getElementById('camera-section');
      
      canvas.width = gameSection.clientWidth;
      canvas.height = gameSection.clientHeight;
      
      handCanvas.width = cameraSection.clientWidth;
      handCanvas.height = cameraSection.clientHeight;
      
      if (gameActive) {
        // Ø¥Ø¹Ø§Ø¯Ø© ØªØ¹ÙŠÙŠÙ† Ù…ÙˆÙ‚Ø¹ Ø§Ù„Ø«Ø¹Ø¨Ø§Ù† ÙˆØ§Ù„Ø·Ø¹Ø§Ù… Ø¥Ø°Ø§ ØªØºÙŠØ± Ø­Ø¬Ù… Ø§Ù„Ø´Ø§Ø´Ø©
        snake[0] = {x: canvas.width/2, y: canvas.height/2};
        randomFood();
      }
    }
    
    // Ø¥Ø¹Ø¯Ø§Ø¯ Ø§Ù„ÙƒØ§Ù…ÙŠØ±Ø§
    async function setupCamera() {
      try {
        const stream = await navigator.mediaDevices.getUserMedia({
          video: { 
            facingMode: "environment", // Ø§Ø³ØªØ®Ø¯Ø§Ù… Ø§Ù„ÙƒØ§Ù…ÙŠØ±Ø§ Ø§Ù„Ø®Ù„ÙÙŠØ©
            width: { ideal: 640 },
            height: { ideal: 480 }
          } 
        });
        video.srcObject = stream;
        return new Promise(resolve => {
          video.onloadedmetadata = () => {
            video.width = video.videoWidth;
            video.height = video.videoHeight;
            resolve(video);
          };
        });
      } catch (error) {
        console.error("Ø®Ø·Ø£ ÙÙŠ Ø§Ù„ÙˆØµÙˆÙ„ Ù„Ù„ÙƒØ§Ù…ÙŠØ±Ø§:", error);
        // Ù…Ø­Ø§ÙˆÙ„Ø© Ø§Ø³ØªØ®Ø¯Ø§Ù… Ø§Ù„ÙƒØ§Ù…ÙŠØ±Ø§ Ø§Ù„Ø£Ù…Ø§Ù…ÙŠØ© Ø¥Ø°Ø§ ÙØ´Ù„Øª Ø§Ù„Ø®Ù„ÙÙŠØ©
        try {
          const stream = await navigator.mediaDevices.getUserMedia({
            video: { 
              facingMode: "user",
              width: { ideal: 640 },
              height: { ideal: 480 }
            } 
          });
          video.srcObject = stream;
          return new Promise(resolve => {
            video.onloadedmetadata = () => {
              video.width = video.videoWidth;
              video.height = video.videoHeight;
              resolve(video);
            };
          });
        } catch (error2) {
          alert("ØªØ¹Ø°Ø± Ø§Ù„ÙˆØµÙˆÙ„ Ù„Ù„ÙƒØ§Ù…ÙŠØ±Ø§. ÙŠØ±Ø¬Ù‰ Ø§Ù„ØªØ£ÙƒØ¯ Ù…Ù† Ø§Ù„Ø³Ù…Ø§Ø­ Ø¨Ø§Ø³ØªØ®Ø¯Ø§Ù… Ø§Ù„ÙƒØ§Ù…ÙŠØ±Ø§ ÙˆØªØ­Ø¯ÙŠØ« Ø§Ù„ØµÙØ­Ø©.");
          return null;
        }
      }
    }

    // Ø§Ù„Ø¯Ø§Ù„Ø© Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠØ©
    async function main() {
      loading.style.display = "block";
      
      try {
        // Ø¥Ø¹Ø¯Ø§Ø¯ TensorFlow.js
        await tf.setBackend('webgl');
        
        // ØªØ­Ù…ÙŠÙ„ Ù†Ù…ÙˆØ°Ø¬ handpose
        model = await handpose.load();
        
        // Ø¥Ø¹Ø¯Ø§Ø¯ Ø§Ù„ÙƒØ§Ù…ÙŠØ±Ø§
        const cameraReady = await setupCamera();
        if (!cameraReady) return;
        
        loading.style.display = "none";
        startScreen.style.display = "flex";
      } catch (error) {
        console.error("Ø®Ø·Ø£ ÙÙŠ Ø§Ù„ØªØ­Ù…ÙŠÙ„:", error);
        loading.textContent = "Ø­Ø¯Ø« Ø®Ø·Ø£ ÙÙŠ Ø§Ù„ØªØ­Ù…ÙŠÙ„. ÙŠØ±Ø¬Ù‰ ØªØ­Ø¯ÙŠØ« Ø§Ù„ØµÙØ­Ø©.";
      }
    }

    // ØªÙˆÙ„ÙŠØ¯ Ø·Ø¹Ø§Ù… Ø¹Ø´ÙˆØ§Ø¦ÙŠ
    function randomFood() {
      food = {
        x: Math.random() * (canvas.width - 60) + 30,
        y: Math.random() * (canvas.height - 60) + 30
      };
    }

    // ØªØ­Ø¯ÙŠØ« Ø§Ù„Ù†Ù‚Ø§Ø·
    function updateScore() {
      scoreDisplay.textContent = `Ø§Ù„Ù†Ù‚Ø§Ø·: ${score}`;
    }
    
    // ØªØ­Ø¯ÙŠØ« Ø¹Ø±Ø¶ Ø§Ù„Ù…Ø³Ø§Ø¹Ø¯Ø© Ø§Ù„Ø°ÙƒÙŠØ©
    function updateAIAssistDisplay() {
      aiAssistDisplay.textContent = `Ø§Ù„Ù…Ø³Ø§Ø¹Ø¯Ø© Ø§Ù„Ø°ÙƒÙŠØ©: ${aiAssistActive ? 'Ù†Ø´Ø·Ø©' : 'ØºÙŠØ± Ù†Ø´Ø·Ø©'}`;
    }

    // Ø¥Ù†Ø´Ø§Ø¡ ØªØ£Ø«ÙŠØ±Ø§Øª Ø¬Ø³ÙŠÙ…Ø§Øª
    function createParticles(x, y, color, count = 10) {
      for (let i = 0; i < count; i++) {
        particles.push({
          x: x,
          y: y,
          color: color,
          size: Math.random() * 5 + 2,
          speedX: (Math.random() - 0.5) * 10,
          speedY: (Math.random() - 0.5) * 10,
          life: 1.0
        });
      }
    }

    // ØªØ­Ø¯ÙŠØ« ÙˆØ±Ø³Ù… Ø§Ù„Ø¬Ø³ÙŠÙ…Ø§Øª
    function updateParticles() {
      for (let i = particles.length - 1; i >= 0; i--) {
        const p = particles[i];
        p.x += p.speedX;
        p.y += p.speedY;
        p.life -= 0.02;
        
        if (p.life <= 0) {
          particles.splice(i, 1);
        } else {
          ctx.globalAlpha = p.life;
          ctx.fillStyle = p.color;
          ctx.beginPath();
          ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
          ctx.fill();
        }
      }
      ctx.globalAlpha = 1.0;
    }

    // Ø±Ø³Ù… Ø®ÙŠÙˆØ· Ø§Ù„Ø°ÙƒØ§Ø¡ Ø§Ù„Ø§ØµØ·Ù†Ø§Ø¹ÙŠ Ø¹Ù„Ù‰ Ø§Ù„ÙŠØ¯
    function drawAIHandLines(predictions) {
      handCtx.clearRect(0, 0, handCanvas.width, handCanvas.height);
      
      if (predictions.length > 0) {
        const landmarks = predictions[0].landmarks;
        
        // Ø±Ø³Ù… Ù†Ù‚Ø§Ø· Ø§Ù„ÙŠØ¯
        for (let i = 0; i < landmarks.length; i++) {
          const x = landmarks[i][0] * (handCanvas.width / video.videoWidth);
          const y = landmarks[i][1] * (handCanvas.height / video.videoHeight);
          
          handCtx.beginPath();
          handCtx.arc(x, y, 4, 0, 2 * Math.PI);
          handCtx.fillStyle = '#00ff00';
          handCtx.fill();
        }
        
        // Ø±Ø³Ù… Ø®Ø·ÙˆØ· ØªÙˆØµÙŠÙ„ Ø¨ÙŠÙ† Ø§Ù„Ù†Ù‚Ø§Ø·
        const connections = [
          [0, 1], [1, 2], [2, 3], [3, 4], // Ø¥Ø¨Ù‡Ø§Ù…
          [0, 5], [5, 6], [6, 7], [7, 8], // Ø³Ø¨Ø§Ø¨Ø©
          [0, 9], [9, 10], [10, 11], [11, 12], // ÙˆØ³Ø·Ù‰
          [0, 13], [13, 14], [14, 15], [15, 16], // Ø¨Ù†ØµØ±
          [0, 17], [17, 18], [18, 19], [19, 20] // Ø®Ù†ØµØ±
        ];
        
        handCtx.strokeStyle = '#ff00ff';
        handCtx.lineWidth = 2;
        
        for (let i = 0; i < connections.length; i++) {
          const start = connections[i][0];
          const end = connections[i][1];
          
          const startX = landmarks[start][0] * (handCanvas.width / video.videoWidth);
          const startY = landmarks[start][1] * (handCanvas.height / video.videoHeight);
          const endX = landmarks[end][0] * (handCanvas.width / video.videoWidth);
          const endY = landmarks[end][1] * (handCanvas.height / video.videoHeight);
          
          handCtx.beginPath();
          handCtx.moveTo(startX, startY);
          handCtx.lineTo(endX, endY);
          handCtx.stroke();
        }
        
        // Ø±Ø³Ù… Ø®Ø· Ø¥Ø¶Ø§ÙÙŠ Ù„Ø¥ØµØ¨Ø¹ Ø§Ù„Ø³Ø¨Ø§Ø¨Ø© (Ù„Ù„ØªØ£ÙƒÙŠØ¯)
        const indexFingerTip = landmarks[8];
        const indexFingerBase = landmarks[5];
        
        const tipX = indexFingerTip[0] * (handCanvas.width / video.videoWidth);
        const tipY = indexFingerTip[1] * (handCanvas.height / video.videoHeight);
        const baseX = indexFingerBase[0] * (handCanvas.width / video.videoWidth);
        const baseY = indexFingerBase[1] * (handCanvas.height / video.videoHeight);
        
        handCtx.strokeStyle = '#ffff00';
        handCtx.lineWidth = 3;
        handCtx.beginPath();
        handCtx.moveTo(baseX, baseY);
        handCtx.lineTo(tipX, tipY);
        handCtx.stroke();
        
        // Ø±Ø³Ù… Ø¯Ø§Ø¦Ø±Ø© Ø­ÙˆÙ„ Ø¥ØµØ¨Ø¹ Ø§Ù„Ø³Ø¨Ø§Ø¨Ø©
        handCtx.beginPath();
        handCtx.arc(tipX, tipY, 15, 0, 2 * Math.PI);
        handCtx.strokeStyle = '#ffff00';
        handCtx.lineWidth = 2;
        handCtx.stroke();
      }
    }

    // Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø§Ù„Ø§ØµØ·Ø¯Ø§Ù…
    function checkCollision() {
      const head = snake[snake.length - 1];
      
      // Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø§Ù„Ø§ØµØ·Ø¯Ø§Ù… Ø¨Ø§Ù„Ø¬Ø¯Ø±Ø§Ù†
      if (head.x < 0 || head.x > canvas.width || head.y < 0 || head.y > canvas.height) {
        return true;
      }
      
      // Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø§Ù„Ø§ØµØ·Ø¯Ø§Ù… Ø¨Ø§Ù„Ù†ÙØ³ (Ø¨Ø¯Ø¡Ø§Ù‹ Ù…Ù† Ø§Ù„Ø¹Ù†ØµØ± Ø§Ù„Ø±Ø§Ø¨Ø¹ Ù„ØªØ¬Ù†Ø¨ Ø§Ù„Ø§ØµØ·Ø¯Ø§Ù… Ø¨Ø§Ù„Ø¹Ù†Ø§ØµØ± Ø§Ù„Ù‚Ø±ÙŠØ¨Ø©)
      for (let i = 0; i < snake.length - 10; i++) {
        const dx = head.x - snake[i].x;
        const dy = head.y - snake[i].y;
        const dist = Math.sqrt(dx * dx + dy * dy);
        
        if (dist < 15) {
          return true;
        }
      }
      
      return false;
    }
    
    // Ø§Ù„Ù…Ø³Ø§Ø¹Ø¯Ø© Ø§Ù„Ø°ÙƒÙŠØ© - Ø¬Ø¹Ù„ Ø§Ù„Ù„Ø¹Ø¨Ø© Ø£Ø³Ù‡Ù„
    function applyAIAssist(targetX, targetY) {
      if (!aiAssistActive) return { x: targetX, y: targetY };
      
      const head = snake[snake.length - 1];
      
      // Ø¥Ø°Ø§ ÙƒØ§Ù† Ø§Ù„Ù‡Ø¯Ù Ù‚Ø±ÙŠØ¨Ø§Ù‹ Ù…Ù† Ø§Ù„Ø·Ø¹Ø§Ù…ØŒ ØªÙˆØ¬ÙŠÙ‡ Ù†Ø­Ùˆ Ø§Ù„Ø·Ø¹Ø§Ù…
      const dxToFood = food.x - head.x;
      const dyToFood = food.y - head.y;
      const distToFood = Math.sqrt(dxToFood * dxToFood + dyToFood * dyToFood);
      
      if (distToFood < 200) {
        // ØªÙˆØ¬ÙŠÙ‡ Ø¬Ø²Ø¦ÙŠ Ù†Ø­Ùˆ Ø§Ù„Ø·Ø¹Ø§Ù…
        const foodWeight = assistLevel * (1 - distToFood / 200);
        targetX = targetX * (1 - foodWeight) + food.x * foodWeight;
        targetY = targetY * (1 - foodWeight) + food.y * foodWeight;
      }
      
      // ØªØ¬Ù†Ø¨ Ø§Ù„Ø§ØµØ·Ø¯Ø§Ù… Ø¨Ø§Ù„Ù†ÙØ³
      for (let i = 0; i < snake.length - 5; i++) {
        const dxToBody = head.x - snake[i].x;
        const dyToBody = head.y - snake[i].y;
        const distToBody = Math.sqrt(dxToBody * dxToBody + dyToBody * dyToBody);
        
        if (distToBody < 50) {
          // ØªØ¬Ù†Ø¨ Ø§Ù„Ø¬Ø²Ø¡ Ù…Ù† Ø§Ù„Ø¬Ø³Ù…
          const avoidWeight = assistLevel * (1 - distToBody / 50);
          targetX = targetX + (dxToBody / distToBody) * 30 * avoidWeight;
          targetY = targetY + (dyToBody / distToBody) * 30 * avoidWeight;
        }
      }
      
      // ØªØ¬Ù†Ø¨ Ø§Ù„Ø¬Ø¯Ø±Ø§Ù†
      const wallMargin = 50;
      if (head.x < wallMargin) {
        targetX = Math.max(targetX, head.x + 10);
      } else if (head.x > canvas.width - wallMargin) {
        targetX = Math.min(targetX, head.x - 10);
      }
      
      if (head.y < wallMargin) {
        targetY = Math.max(targetY, head.y + 10);
      } else if (head.y > canvas.height - wallMargin) {
        targetY = Math.min(targetY, head.y - 10);
      }
      
      return { x: targetX, y: targetY };
    }

    // Ø­Ù„Ù‚Ø© Ø§Ù„Ø±Ø³Ù… Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠØ©
    async function drawLoop() {
      if (!gameActive) return;
      
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      
      // ØªØ­Ø¯ÙŠØ« Ø§Ù„ØªÙ†Ø¨Ø¤Ø§Øª Ø¨ÙØ§ØµÙ„ Ø²Ù…Ù†ÙŠ Ù„ØªÙ‚Ù„ÙŠÙ„ Ø§Ù„Ø­Ù…Ù„
      const currentTime = Date.now();
      if (currentTime - lastPredictionTime > predictionInterval) {
        lastPredictionTime = currentTime;
        
        const predictions = await model.estimateHands(video);
        
        // Ø±Ø³Ù… Ø®ÙŠÙˆØ· Ø§Ù„Ø°ÙƒØ§Ø¡ Ø§Ù„Ø§ØµØ·Ù†Ø§Ø¹ÙŠ Ø¹Ù„Ù‰ Ø§Ù„ÙŠØ¯
        drawAIHandLines(predictions);
        
        if (predictions.length > 0) {
          let x = predictions[0].landmarks[8][0] * (canvas.width / video.videoWidth);
          let y = predictions[0].landmarks[8][1] * (canvas.height / video.videoHeight);
          
          // ØªØ·Ø¨ÙŠÙ‚ Ø§Ù„Ù…Ø³Ø§Ø¹Ø¯Ø© Ø§Ù„Ø°ÙƒÙŠØ©
          const assistedTarget = applyAIAssist(x, y);
          x = assistedTarget.x;
          y = assistedTarget.y;
          
          // ØªØ­Ø¯ÙŠØ« Ù…Ø¤Ø´Ø± Ø§Ù„ÙŠØ¯
          handIndicator.style.display = 'block';
          handIndicator.style.left = (x - 15) + 'px';
          handIndicator.style.top = (y - 15) + 'px';
          
          // ØªØ³Ø¬ÙŠÙ„ Ø¢Ø®Ø± Ù…ÙˆÙ‚Ø¹ Ù„Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø§Ø³ØªÙ…Ø±Ø§Ø± Ø§Ù„ÙƒØ´Ù
          lastHandPosition = { x, y };
          handDetected = true;
          
          // Ø¥Ø¶Ø§ÙØ© Ù†Ù‚Ø·Ø© Ø¬Ø¯ÙŠØ¯Ø© Ù„Ù„Ø«Ø¹Ø¨Ø§Ù†
          snake.push({x, y});
          if (snake.length > maxLength) snake.shift();
          
          // Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø£ÙƒÙ„ Ø§Ù„Ø·Ø¹Ø§Ù…
          const dx = x - food.x;
          const dy = y - food.y;
          const dist = Math.sqrt(dx * dx + dy * dy);
          
          if (dist < 30) {
            createParticles(food.x, food.y, '#ff0000', 15);
            randomFood();
            maxLength += 5;
            score++;
            updateScore();
            
            // ØªÙ‚Ù„ÙŠÙ„ Ù…Ø³ØªÙˆÙ‰ Ø§Ù„Ù…Ø³Ø§Ø¹Ø¯Ø© ØªØ¯Ø±ÙŠØ¬ÙŠØ§Ù‹ Ù…Ø¹ Ø²ÙŠØ§Ø¯Ø© Ø§Ù„Ù†Ù‚Ø§Ø·
            if (score % 5 === 0 && assistLevel > 0.2) {
              assistLevel -= 0.1;
            }
            
            // Ø¥Ø¶Ø§ÙØ© ØªØ£Ø«ÙŠØ± ØµÙˆØªÙŠ (Ù…Ø­Ø§ÙƒØ§Ø©)
            try {
              const audioContext = new (window.AudioContext || window.webkitAudioContext)();
              const oscillator = audioContext.createOscillator();
              const gainNode = audioContext.createGain();
              
              oscillator.connect(gainNode);
              gainNode.connect(audioContext.destination);
              
              oscillator.frequency.value = 800;
              gainNode.gain.value = 0.1;
              
              oscillator.start();
              gainNode.gain.exponentialRampToValueAtTime(0.001, audioContext.currentTime + 0.2);
              oscillator.stop(audioContext.currentTime + 0.2);
            } catch (e) {
              console.log("ØªØ¹Ø°Ø± ØªØ´ØºÙŠÙ„ Ø§Ù„ØµÙˆØª");
            }
          }
          
          // Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø§Ù„Ø§ØµØ·Ø¯Ø§Ù…
          if (checkCollision()) {
            gameOver();
            return;
          }
        } else {
          // Ø¥Ø®ÙØ§Ø¡ Ù…Ø¤Ø´Ø± Ø§Ù„ÙŠØ¯ Ø¥Ø°Ø§ Ù„Ù… ÙŠØªÙ… Ø§Ù„ÙƒØ´Ù Ø¹Ù† ÙŠØ¯
          handIndicator.style.display = 'none';
          handDetected = false;
          
          // Ø¥Ø°Ø§ Ù„Ù… ÙŠØªÙ… Ø§Ù„ÙƒØ´Ù Ø¹Ù† Ø§Ù„ÙŠØ¯ØŒ Ø§Ø³ØªÙ…Ø± ÙÙŠ Ø§Ù„Ø­Ø±ÙƒØ© ÙÙŠ Ø§Ù„Ø§ØªØ¬Ø§Ù‡ Ø§Ù„Ø£Ø®ÙŠØ±
          if (handDetected && snake.length > 1) {
            const lastSegment = snake[snake.length - 1];
            const secondLastSegment = snake[snake.length - 2];
            const dx = lastSegment.x - secondLastSegment.x;
            const dy = lastSegment.y - secondLastSegment.y;
            
            snake.push({
              x: lastSegment.x + dx * 0.5,
              y: lastSegment.y + dy * 0.5
            });
            
            if (snake.length > maxLength) snake.shift();
            
            // Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø§Ù„Ø§ØµØ·Ø¯Ø§Ù…
            if (checkCollision()) {
              gameOver();
              return;
            }
          }
        }
      }
      
      // Ø±Ø³Ù… Ø§Ù„Ø«Ø¹Ø¨Ø§Ù†
      ctx.beginPath();
      for (let i = 1; i < snake.length; i++) {
        const gradient = ctx.createLinearGradient(
          snake[i-1].x, snake[i-1].y, 
          snake[i].x, snake[i].y
        );
        gradient.addColorStop(0, '#00ff00');
        gradient.addColorStop(1, '#00cc00');
        
        ctx.strokeStyle = gradient;
        ctx.lineWidth = 8;
        ctx.lineCap = 'round';
        ctx.lineJoin = 'round';
        
        ctx.moveTo(snake[i-1].x, snake[i-1].y);
        ctx.lineTo(snake[i].x, snake[i].y);
        ctx.stroke();
      }
      
      // Ø±Ø³Ù… Ø±Ø£Ø³ Ø§Ù„Ø«Ø¹Ø¨Ø§Ù†
      if (snake.length > 0) {
        const head = snake[snake.length - 1];
        ctx.beginPath();
        ctx.arc(head.x, head.y, 10, 0, Math.PI * 2);
        ctx.fillStyle = '#00ff00';
        ctx.fill();
        ctx.strokeStyle = '#ffffff';
        ctx.lineWidth = 2;
        ctx.stroke();
        
        // Ø±Ø³Ù… Ø§Ù„Ø¹ÙŠÙ†ÙŠÙ†
        ctx.beginPath();
        ctx.arc(head.x - 4, head.y - 4, 3, 0, Math.PI * 2);
        ctx.arc(head.x + 4, head.y - 4, 3, 0, Math.PI * 2);
        ctx.fillStyle = '#000';
        ctx.fill();
      }
      
      // Ø±Ø³Ù… Ø§Ù„ØªÙØ§Ø­Ø©
      ctx.beginPath();
      ctx.arc(food.x, food.y, 20, 0, Math.PI * 2);
      
      // ØªØ¯Ø±Ø¬ Ù„ÙˆÙ†ÙŠ Ù„Ù„ØªÙØ§Ø­Ø©
      const gradient = ctx.createRadialGradient(
        food.x - 5, food.y - 5, 5,
        food.x, food.y, 20
      );
      gradient.addColorStop(0, '#ff3333');
      gradient.addColorStop(1, '#cc0000');
      
      ctx.fillStyle = gradient;
      ctx.fill();
      
      // Ø³Ø§Ù‚ Ø§Ù„ØªÙØ§Ø­Ø©
      ctx.beginPath();
      ctx.moveTo(food.x, food.y - 20);
      ctx.lineTo(food.x, food.y - 30);
      ctx.strokeStyle = '#8B4513';
      ctx.lineWidth = 3;
      ctx.stroke();
      
      // ÙˆØ±Ù‚Ø© Ø§Ù„ØªÙØ§Ø­Ø©
      ctx.beginPath();
      ctx.arc(food.x + 5, food.y - 25, 8, 0, Math.PI * 1.5);
      ctx.fillStyle = '#00cc00';
      ctx.fill();
      
      // ØªØ­Ø¯ÙŠØ« ÙˆØ±Ø³Ù… Ø§Ù„Ø¬Ø³ÙŠÙ…Ø§Øª
      updateParticles();
      
      requestAnimationFrame(drawLoop);
    }

    // Ù†Ù‡Ø§ÙŠØ© Ø§Ù„Ù„Ø¹Ø¨Ø©
    function gameOver() {
      gameActive = false;
      finalScore.textContent = `Ø§Ù„Ù†Ù‚Ø§Ø·: ${score}`;
      gameOverScreen.style.display = "flex";
      handIndicator.style.display = 'none';
      
      // ØªØ£Ø«ÙŠØ± ØµÙˆØªÙŠ Ù„Ù†Ù‡Ø§ÙŠØ© Ø§Ù„Ù„Ø¹Ø¨Ø©
      try {
        const audioContext = new (window.AudioContext || window.webkitAudioContext)();
        const oscillator = audioContext.createOscillator();
        const gainNode = audioContext.createGain();
        
        oscillator.connect(gainNode);
        gainNode.connect(audioContext.destination);
        
        oscillator.frequency.value = 200;
        gainNode.gain.value = 0.1;
        
        oscillator.start();
        gainNode.gain.exponentialRampToValueAtTime(0.001, audioContext.currentTime + 0.5);
        oscillator.stop(audioContext.currentTime + 0.5);
      } catch (e) {
        console.log("ØªØ¹Ø°Ø± ØªØ´ØºÙŠÙ„ Ø§Ù„ØµÙˆØª");
      }
    }

    // Ù…Ø³ØªÙ…Ø¹ÙŠ Ø§Ù„Ø£Ø­Ø¯Ø§Ø«
    startBtn.addEventListener("click", () => {
      startScreen.style.display = "none";
      resizeCanvas();
      initGame();
      drawLoop();
    });

    restartBtn.addEventListener("click", () => {
      gameOverScreen.style.display = "none";
      initGame();
      drawLoop();
    });

    // ØªØ¨Ø¯ÙŠÙ„ Ø§Ù„Ù…Ø³Ø§Ø¹Ø¯Ø© Ø§Ù„Ø°ÙƒÙŠØ© Ø¨Ø§Ù„Ø¶ØºØ· Ø¹Ù„Ù‰ Ø§Ù„Ù…Ø³Ø§ÙØ©
    document.addEventListener('keydown', (e) => {
      if (e.code === 'Space' && gameActive) {
        aiAssistActive = !aiAssistActive;
        updateAIAssistDisplay();
      }
    });

    window.addEventListener("resize", resizeCanvas);

    // Ø¨Ø¯Ø¡ Ø§Ù„ØªØ·Ø¨ÙŠÙ‚
    main();
  </script>
</body>
</html>